<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: table_store.proto

namespace Aliyun\OTS\ProtoBuffer\Protocol;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>aliyun.OTS.ProtoBuffer.Protocol.ComputeSplitPointsBySizeResponse</code>
 */
class ComputeSplitPointsBySizeResponse extends \Aliyun\OTS\ProtoBuffer\Protocol\Message
{
    /**
     * Generated from protobuf field <code>required .aliyun.OTS.ProtoBuffer.Protocol.ConsumedCapacity consumed = 1;</code>
     */
    private $consumed = null;
    private $has_consumed = false;
    /**
     * Generated from protobuf field <code>repeated .aliyun.OTS.ProtoBuffer.Protocol.PrimaryKeySchema schema = 2;</code>
     */
    private $schema;
    private $has_schema = false;
    /**
     **
     * Split points between splits, in the increasing order
     * A split is a consecutive range of primary keys,
     * whose data size is about split_size specified in the request.
     * The size could be hard to be precise.
     * A split point is an array of primary-key column w.r.t. table schema,
     * which is never longer than that of table schema.
     * Tailing -inf will be omitted to reduce transmission payloads.
     *
     * Generated from protobuf field <code>repeated bytes split_points = 3;</code>
     */
    private $split_points;
    private $has_split_points = false;
    /**
     * Generated from protobuf field <code>repeated .aliyun.OTS.ProtoBuffer.Protocol.ComputeSplitPointsBySizeResponse.SplitLocation locations = 4;</code>
     */
    private $locations;
    private $has_locations = false;

    public function __construct() {
        \GPBMetadata\TableStore::initOnce();
        parent::__construct();
    }

    /**
     * Generated from protobuf field <code>required .aliyun.OTS.ProtoBuffer.Protocol.ConsumedCapacity consumed = 1;</code>
     * @return \Aliyun\OTS\ProtoBuffer\Protocol\ConsumedCapacity
     */
    public function getConsumed()
    {
        return $this->consumed;
    }

    /**
     * Generated from protobuf field <code>required .aliyun.OTS.ProtoBuffer.Protocol.ConsumedCapacity consumed = 1;</code>
     * @param \Aliyun\OTS\ProtoBuffer\Protocol\ConsumedCapacity $var
     * @return $this
     */
    public function setConsumed($var)
    {
        GPBUtil::checkMessage($var, \Aliyun\OTS\ProtoBuffer\Protocol\ConsumedCapacity::class);
        $this->consumed = $var;
        $this->has_consumed = true;

        return $this;
    }

    public function hasConsumed()
    {
        return $this->has_consumed;
    }

    /**
     * Generated from protobuf field <code>repeated .aliyun.OTS.ProtoBuffer.Protocol.PrimaryKeySchema schema = 2;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getSchema()
    {
        return $this->schema;
    }

    /**
     * Generated from protobuf field <code>repeated .aliyun.OTS.ProtoBuffer.Protocol.PrimaryKeySchema schema = 2;</code>
     * @param \Aliyun\OTS\ProtoBuffer\Protocol\PrimaryKeySchema[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setSchema($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Aliyun\OTS\ProtoBuffer\Protocol\PrimaryKeySchema::class);
        $this->schema = $arr;
        $this->has_schema = true;

        return $this;
    }

    public function hasSchema()
    {
        return $this->has_schema;
    }

    /**
     **
     * Split points between splits, in the increasing order
     * A split is a consecutive range of primary keys,
     * whose data size is about split_size specified in the request.
     * The size could be hard to be precise.
     * A split point is an array of primary-key column w.r.t. table schema,
     * which is never longer than that of table schema.
     * Tailing -inf will be omitted to reduce transmission payloads.
     *
     * Generated from protobuf field <code>repeated bytes split_points = 3;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getSplitPoints()
    {
        return $this->split_points;
    }

    /**
     **
     * Split points between splits, in the increasing order
     * A split is a consecutive range of primary keys,
     * whose data size is about split_size specified in the request.
     * The size could be hard to be precise.
     * A split point is an array of primary-key column w.r.t. table schema,
     * which is never longer than that of table schema.
     * Tailing -inf will be omitted to reduce transmission payloads.
     *
     * Generated from protobuf field <code>repeated bytes split_points = 3;</code>
     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setSplitPoints($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::BYTES);
        $this->split_points = $arr;
        $this->has_split_points = true;

        return $this;
    }

    public function hasSplitPoints()
    {
        return $this->has_split_points;
    }

    /**
     * Generated from protobuf field <code>repeated .aliyun.OTS.ProtoBuffer.Protocol.ComputeSplitPointsBySizeResponse.SplitLocation locations = 4;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getLocations()
    {
        return $this->locations;
    }

    /**
     * Generated from protobuf field <code>repeated .aliyun.OTS.ProtoBuffer.Protocol.ComputeSplitPointsBySizeResponse.SplitLocation locations = 4;</code>
     * @param \Aliyun\OTS\ProtoBuffer\Protocol\ComputeSplitPointsBySizeResponse_SplitLocation[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setLocations($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Aliyun\OTS\ProtoBuffer\Protocol\ComputeSplitPointsBySizeResponse_SplitLocation::class);
        $this->locations = $arr;
        $this->has_locations = true;

        return $this;
    }

    public function hasLocations()
    {
        return $this->has_locations;
    }

}

